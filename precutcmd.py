#!/usr/bin/env python

#
#############################################################################
#
# precutcmd.py - Cut/Cull source media files without re-encoding
# using the edits from an Adobe Premiere project to determine
# where to split/cut the files. The input into this utility is a Final Cut
# 7 XML file, which can be generated by Premiere via File -> Export ->
# Final Cut Pro XML. The output is either indiviual clip files for each
# cut or a combined file of all the individual generated cuts, grouped by
# project, seqeunce, track, or belonging to same source media file (default)
#
# Project page: http://www.testcams.com/
#
# Copyright (C) 2017, testcams.com
#
# This module is licensed under GPL v3: http://www.gnu.org/licenses/gpl-3.0.html
#
#############################################################################
#


# future definitions in case we're running under Python 2.x
from __future__ import print_function
from __future__ import division

import xml.etree.ElementTree as ET
import argparse
import os
import platform
import errno
import sys
import re
import subprocess
import time
if sys.version_info.major == 2:
    import urlparse as _urlparse
else:
    import urllib.parse as _urlparse

#
# App name and version
#
APP_NAME = "precutcmd"
APP_NAME_GROUP = "precut"   # used only for establishing app data folder name
APP_VERSION = "0.91"

#
# custom errno exit values generated by this app
#
ERRNO_BAD_CMD_LINE_ARG                          = 5000  # bad command line argument specified
ERRNO_XML_PARSE_FAILED                          = 5001  # xml.etree.ElementTree.parse() failed
ERRNO_XML_ELEMENT_NOT_FOUND                     = 5002  # an XML element needed could not be found
ERRNO_XML_ELEMENT_MISSING_ATTRIBUTE             = 5003  # an XML element is missing a needed attribute
ERRNO_XML_ELEMENT_MISSING_VALUE                 = 5004  # an XML element is missing a needed value
ERRNO_XML_ELEMENT_HAS_NON_NUMERIC_VALUES        = 5005  # an XML element has non-numeric values in a field where only numeric values were expected
ERRNO_XML_ELEMENT_HAS_ZERO_VALUE                = 5006  # an XML element has a zero value where a non-zero value is required
ERRNO_VIDEO_SOURCE_FOR_CLIP_REF_NOT_FOUND       = 5020  # FILE XML element corresponding to an XML clip item reference could not be found
ERRNO_SOURCE_MEDIA_FILE_NOT_FOUND               = 5021  # media file corresonding to an XML FILE element could not be found
ERRNO_FFMPEG_EXEC_LAUNCH_FAILED                 = 5022  # launch of ffmpeg failed (mechanics of spawning ffmpeg failed - not that ffmpeg returned error
ERRNO_FILE_EXISTS_USER_SPECIFIED_EXIT           = 5023  # an output file already exists and user configured app to exit on this condition
ERRNO_FFMPEG_OUTPUT_FILE_NOT_FOUND              = 5024  # ffmpeg reported success but the output file it was supposed to generate is not there
# internal values that are never returned as exit code
ERRNO_FILE_SKIPPED_DUE_TO_EXISTING_FILE         = 5900


#
# structure to hold various global vars
#
class GlobalVarsStruct(object):
    def __init__(self):
        self.isWin32 = None                             # True if we're running on a Windows platform
        self.isOSX = None                               # True if we're runnong on an OSX platform
        self.disableLoggingToFile = False               # True if user disabled logging to file
        self.args = None                                # dictionary of command-line arguments (generated by argparse)
        self.appDir = None                              # directory where script is located. this path is used to store all metadata files, in case script is run in different working directory
        self.appDataDir = None                          # directory where we keep app logs
        self.outputDirSpecified = False                 # TRUE if user explicitly specified an output dir, FALSE if not (in which case self.outputDir will be set by default logic)
        self.outputDir = None                           # directory to store output (will be "" if not specified)
        self.scratchDirSpecified = False                # TRUE if user explicitly specified a scratch dir, FALSE if not (in which case self.scratchDir will be set by default logic)
        self.scratchDir = None                          # directory to store temporary/working files (will be self.outputDir if not specified)
        self.appStartTimeEpoch = None                   # time that application started
        self.applog = None                              # instance of AppLog class
        self.applogFilename = None                      # name of session log filename
        self.ffmpegToolsPath = None                     # path to ffmpeg tools
        # exit cleanup tracking vars
        self.filesToDeleteOnAppExit = []                # list of generated temporary files to delete if app ends early due to error/exception


#
# global vars
#
g  = GlobalVarsStruct()


#########################################################################################
#                                                                                       #
#                                   Command-Line Logic                                  #
#                                                                                       #
#########################################################################################


#
# processCmdLine - Processes command line arguments
#
class ArgumentParserError(Exception): pass # from http://stackoverflow.com/questions/14728376/i-want-python-argparse-to-throw-an-exception-rather-than-usage
class ArgumentParserWithException(argparse.ArgumentParser):
    def error(self, message):
        raise ArgumentParserError(message)


#
# called when a command-line error is detected. shuts down the applog class
# and then invokves sys.exit() with specified error code
#
def exitAfterCmdLineError(_errno):
    cleanupAndExitApp(_errno)


#
# Verifies that the path for a command line options exists. If the path doesn't exist
# then the program terminates with a ERRNO_BAD_CMD_LINE_ARG exit code, otherwise it
# converts it to an absolute path and returns it
#
def getAndVerifyCmdLineArgPath(cmdLineOptionName, fReturnEmptyStringIfPathNotSpecified=True):
    path = g.args[cmdLineOptionName]
    if path == None:
        return "" if fReturnEmptyStringIfPathNotSpecified else None
    if not os.path.exists(path):
        g.applog.error("The path specified for --{:s} \"{:s}\" does not exist".format(cmdLineOptionName, path))
        exitAfterCmdLineError(ERRNO_BAD_CMD_LINE_ARG)
    return os.path.abspath(path)


#
# displays application banner
#
def displayAppBanner():
    g.applog.minimal("\n{:s} v{:s} - Cuts videos from edits in Premiere -> FCP7 Export [GPL v3]".format(APP_NAME, APP_VERSION))
    g.applog.minimal("Copyright (c) TestCams.com - Time: {:s}, Py: {:d}.{:d}.{:d}, OS: {:s}\n".format(getDateTimeStr(fMilitaryTime=True),\
        sys.version_info.major, sys.version_info.minor, sys.version_info.micro,
        platform.system()))


#
# processes the command line, terminating if any errors are found in arguments
#
def processCmdLine():

    #
    # note: if you add additional filter options/logic, go to realTimeCapture() to see if those options
    # need to be overriden when we enter the realtime capture phase
    #
    parser = ArgumentParserWithException(fromfile_prefix_chars='!',\
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='App Purpose: Cut videos from edits in Premiere Project -> FCP7 Export',
        epilog="Options can also be specified from a file. Use !<filename>. Each word in the\nfile must be on its own line.\n\nYou "\
            "can abbreviate any argument name provided you use enough characters to\nuniquely distinguish it from other argument names.\n"\
            "\n\n"\
            "Command-Line Examples:\n"\
            "  %(prog)s --outputdir f:\\temp_video myproj.xml (save output files to the f:\\temp_video folder)\n"\
            "  %(prog)s --onlysequences MySequence1 movie5.xml (only process the sequence 'MySequence1')")
    parser.add_argument('xmlsourcefile', nargs=1, metavar="XML source filename", default=None)
    parser.add_argument('--combine', type=str.lower, help='Combine generated clips by track, sequence, sourcemedia, or none (keep individual output clips). Example: --combine sequence. Default = %(default)s', choices=['sourcemedia', 'track', 'sequence', 'none'], default='sourcemedia', metavar='type', required=False)
    parser.add_argument('--outputnamespec', type=str, help='Output filename, with support for substition fields. See online help for documentation on \'spec\'. Default depends on --combine value', default=None, metavar="spec", required=False)
    parser.add_argument('--outputdir', type=str, help='Directory to store output files to.  Default is directory of source media file (--combine=none) or current directory (combined files). If path contains any spaces enclose it in double quotes. Example: --outputdir \"c:\\My Documents"', default=None, metavar="directory", required=False)
    parser.add_argument('--scratchdir', type=str, help='Directory to store temporary working files.  --outputdir rules will be used if no scratch directory specified. If path contains any spaces enclose it in double quotes. Example: --scratchdir \"f:\\temp"', default=None, metavar="directory", required=False)
    parser.add_argument('--handles', type=int, help='Extend start and end points of each clip to include extra footage (handles). Example: --handles 5', default=0, metavar="seconds", required=False)
    parser.add_argument('--ifexists', type=str.lower, choices=['uniquename', 'skip', 'overwrite', 'prompt', 'exit'], help='Action to take if file with same name already exists. Default is "%(default)s"', default='uniquename', required=False)

    parser.add_argument('--onlysequences', type=str, help='Only process specified sequences. Ex: --onlysequences MySequence1 MySequence2. Default is to include all sequences', default=None, nargs='+', metavar="sequence name(s)", required=False)
    parser.add_argument('--excludesequences', type=str, help='Exclude specified sequences from processing. Ex: --excludesequences MySequence1. Default is no exclusions', default=None, nargs='+', metavar="sequence name(s)", required=False)
    parser.add_argument('--onlytracknumbers', type=int, help='Only process specified track numbers (1 = V1, 2 = V2, etc..). Ex: --onlytracknumbers 1 2. Default is to include all tracks', default=None, nargs='+', metavar="track number(s)", required=False)
    parser.add_argument('--excludetracknumbers', type=int, help='Exclude specified track numbers (1 = V1, 2 = V2, etc..) from processing. Ex: --excludetracknumbers  2. Default is no exclusions', default=None, nargs='+', metavar="track number(s)", required=False)
    parser.add_argument('--onlytracks', type=int, help='Only process specified track names. Ex: --onlytracks MyTrack1. Default is to include all tracks', default=None, nargs='+', metavar="track name(s)", required=False)
    parser.add_argument('--excludetracks', type=int, help='Exclude specified track names from processing. Ex: --excludetracks  MyTrack5. Default is no exclusions', default=None, nargs='+', metavar="track name(s)", required=False)

    parser.add_argument('--ffmpegdir', type=str, help='Path to the ffmpeg tools directory on your system. Default assumes ffmpeg is in system path. If path specified contains any spaces enclose it in double quotes. Example: --ffmpegdir \"c:\\misc progs\\ffmpeg"', default=None, metavar="directory", required=False)
    parser.add_argument('--container', type=str, help='Video container (mp4, mov, etc...).  Default is same container type as source media file. Example: --container mp4', default=None, metavar="<file extension>", required=False)
    parser.add_argument('--videoargs', type=str, help='ffmpeg video codec args.  Default is \"%(default)s\". Example: --videoargs=\"-c:v libx264 -preset slow -crf 22"', default="-c:v copy -copyinkf -avoid_negative_ts 1 -copyts", metavar="= <video codec args>", required=False)
    parser.add_argument('--audioargs', type=str, help='ffmpeg audio codec args.  Default is \"%(default)s\". Example: --audioargs="-c:a aac -b:a 128k"', default="-c:a copy", metavar="= <audio codec args>", required=False)
    parser.add_argument('--ffmpegargs', type=str, help='Additional args to ffmpeg.  If specifying multiple args place entire value in double quotes. Example: --ffmpegargs=\"-vsync passthrough"', default="", metavar="= args", required=False)

    # less frequently used options
    parser.add_argument('--logginglevel', type=str.lower, choices=['quiet', 'minimal', 'normal', 'warning', 'verbose', 'debug' ], help='Sets how much information is saved to the result log. Default is "%(default)s"', default='normal', required=False)
    parser.add_argument('--ffmpegconsoleloglevel', type=str, help="Sets the ffmpeg logging level for output to the console. Default = \"%(default)s\"", default='24', metavar="numeric value or word", required=False)
    parser.add_argument('--ffmpegreportloglevel', type=str, help="Sets the ffmpeg logging level for output to the file log. Use \'none\' to disable ffmpeg's file logging. Default = \"%(default)s\"", default='24', metavar="none | ffmpeg numeric value", required=False)
    parser.add_argument('--haltonffmpegerrors', type=str.lower, help="Halt execution if ffmpeg fails. Default = %(default)s", choices=['no', 'yes'], default='yes', required=False)
    parser.add_argument('--retaintempclips', type=str.lower, help="Retain individual output clips even if --combine is not set to none. Default = %(default)s", choices=['no', 'yes'], default='no', required=False)
    parser.add_argument('--insertvideo', type=str, help='Insert specified video in between each clip (when using --combine). Video must be of same video dimensions and codec as source video files.. Example: --insertvideo \"c:\\video\\blackvideo.mp4"', default=None, metavar="file", required=False)

    #
    # if there is a default arguments file present, add it to the argument list so that parse_args() will process it
    #
    defaultArgFilename = os.path.join(g.appDir, "{:s}-defaultopts".format(APP_NAME))
    if os.path.exists(defaultArgFilename):
        sys.argv.insert(1, "!" + defaultArgFilename) # insert as first arg (past script name), so that the options in the file can still be overriden by user-entered cmd line options

    # perform the argparse
    try:
        args = vars(parser.parse_args())
    except ArgumentParserError as e:
        displayAppBanner()
        g.applog.error("Command line error: " + str(e))
        exitAfterCmdLineError(ERRNO_BAD_CMD_LINE_ARG)

    # set our global var to the processed argument list and log them
    g.args = args

    #
    # process any args that need verification/translation/conversion
    #
    if g.args['logginglevel'] == 'quiet':
        g.applog.setLoggingFlags(AppLog.APPLOGF_LEVEL_ERROR)
    elif  g.args['logginglevel'] == 'minimal':
        g.applog.setLoggingFlags(AppLog.APPLOGF_LEVEL_ERROR | AppLog.APPLOGF_LEVEL_MINIMAL)
    elif g.args['logginglevel'] == 'warning':
        g.applog.setLoggingFlags(AppLog.APPLOGF_LEVEL_ERROR | AppLog.APPLOGF_LEVEL_MINIMAL | AppLog.APPLOGF_LEVEL_INFORMATIONAL | AppLog.APPLOGF_LEVEL_WARNING)
    elif g.args['logginglevel'] == 'verbose':
        g.applog.setLoggingFlags(AppLog.APPLOGF_LEVEL_ERROR | AppLog.APPLOGF_LEVEL_MINIMAL | AppLog.APPLOGF_LEVEL_INFORMATIONAL | AppLog.APPLOGF_LEVEL_WARNING | AppLog.APPLOGF_LEVEL_VERBOSE)
    elif g.args['logginglevel'] == 'debug':
        g.applog.setLoggingFlags(AppLog.APPLOGF_LEVEL_ERROR | AppLog.APPLOGF_LEVEL_MINIMAL | AppLog.APPLOGF_LEVEL_INFORMATIONAL | AppLog.APPLOGF_LEVEL_WARNING | AppLog.APPLOGF_LEVEL_VERBOSE | AppLog.APPLOGF_LEVEL_DEBUG)
    # else is 'normal', which we've set to this default

    displayAppBanner()  # this is done after 'logginglevel' is processed in case 'quiet' was specified

    g.outputDir = getAndVerifyCmdLineArgPath('outputdir', fReturnEmptyStringIfPathNotSpecified = True)
    g.outputDirSpecified = g.args['outputdir'] != None

    if g.args['scratchdir'] != None:
        g.scratchDir = getAndVerifyCmdLineArgPath('scratchdir', fReturnEmptyStringIfPathNotSpecified = True)
        g.scratchDirSpecified = True
    else:
        # no scratch directory specified - use output directory instead
        g.scratchDirSpecified = False
        g.scratchDir = g.outputDir

    if g.args['outputnamespec']:
        errMsg = OutputNameSpecDict.validateSpecStr(g.args['outputnamespec'])
        if errMsg:
            g.applog.error(errMsg)
            exitAfterCmdLineError(ERRNO_BAD_CMD_LINE_ARG)

    g.ffmpegToolsPath = getAndVerifyCmdLineArgPath('ffmpegdir', fReturnEmptyStringIfPathNotSpecified = True)

    # log the cmd line arguments
    g.applog.debug("Orig cmd line: {:s}".format(str(sys.argv)))
    g.applog.debug("Processed cmd line: {:s}".format(str(g.args)))


#########################################################################################
#                                                                                       #
#                                     App Logging Class                                 #
#                                                                                       #
#########################################################################################

class AppLog(object):

    # logging level flags
    APPLOGF_LEVEL_ALWAYS            = (0x00000001<<0)
    APPLOGF_LEVEL_ERROR             = (0x00000001<<1)
    APPLOGF_LEVEL_MINIMAL           = (0x00000001<<2)
    APPLOGF_LEVEL_INFORMATIONAL     = (0x00000001<<3)
    APPLOGF_LEVEL_WARNING           = (0x00000001<<4)
    APPLOGF_LEVEL_VERBOSE           = (0x00000001<<5)
    APPLOGF_LEVEL_DEBUG             = (0x00000001<<6)
    APPLOGF_LEVEL_MASK              = 0x000000FF
    APPLOGF_DONT_WRITE_TO_CONSOLE   = (0x00000001<<8)

    def __init__(self):
        self.sessionLogFile = None                      # File object for session log
        self.lifetimeLogFile = None                     # File object for lifetime log
        self.loggingFlags = 0

    def startLogging(self, loggingFlags=None, sessionLogFilename=None, lifetimeLogFilename=None):

        if loggingFlags == None:
            loggingFlags = self.APPLOGF_LEVEL_ERROR | self.APPLOGF_LEVEL_MINIMAL | self.APPLOGF_LEVEL_INFORMATIONAL
        self.setLoggingFlags(loggingFlags)

        if sessionLogFilename:
            try:
                self.sessionLogFile = open(sessionLogFilename, "w")
            except IOError as e:
                print("Unable to open/create logfile \"{:s}\". {:s}".format(sessionLogFilename, str(e)))
                return e.errno
        if lifetimeLogFilename:
            try:
                self.lifetimeLogFile = open(lifetimeLogFilename, "a")
            except IOError as e:
                print("Unable to open/create logfile \"{:s}\". {:s}".format(lifetimeLogFilename, str(e)))
                return e.errno
        return 0

    def setLoggingFlags(self, newLoggingFlags):
        self.loggingFlags = newLoggingFlags | self.APPLOGF_LEVEL_ALWAYS

    def shutdown(self):
        try:
            if self.sessionLogFile:
                self.sessionLogFile.close()
            if self.lifetimeLogFile:
                self.sessionLogFile.close()
        except IOError as e:
            print("Unable to close logfile. {:s}".format(str(e)))

    def addFromFile(self, filename):
        with open(filename, 'r') as inFile:
            inData = inFile.read()
        self.log(inData, self.APPLOGF_DONT_WRITE_TO_CONSOLE | self.APPLOGF_LEVEL_MASK)

    def log(self, str, flags=None):
        if flags == None:
            flags = self.APPLOGF_LEVEL_INFORMATIONAL
        if self.loggingFlags & (flags & self.APPLOGF_LEVEL_MASK):
            if not (flags & self.APPLOGF_DONT_WRITE_TO_CONSOLE):
                if flags & self.APPLOGF_LEVEL_ERROR:
                    print(str, file=sys.stderr)
                else:
                    print(str)
            # redirect output to log file(s)
            if self.sessionLogFile:
                print(str, file=self.sessionLogFile)
            if self.lifetimeLogFile:
                print(str, file=self.lifetimeLogFile)

    #
    # Logging wrapper functions for each logging level
    #
    def info(self, s):
        self.log(s, self.APPLOGF_LEVEL_INFORMATIONAL)
    def minimal(self, s):
        self.log(s, self.APPLOGF_LEVEL_MINIMAL)
    def verbose(self, s):
        self.log(s, self.APPLOGF_LEVEL_VERBOSE)
    def warning(self, s):
        self.log("Warning: " + s, self.APPLOGF_LEVEL_WARNING)
    def error(self, s):
        self.log("Error: " + s, self.APPLOGF_LEVEL_ERROR)
    def debug(self, s):
        self.log("Debug: " + s, self.APPLOGF_LEVEL_DEBUG)

    #
    # Logging check-enabled functions, some used to avoid
    # performance penalty of generating log message
    # if logging level is not enabled
    #
    def isDebugLog(self):
        return (self.loggingFlags & self.APPLOGF_LEVEL_DEBUG)
    def isVerboseLog(self):
        return (self.loggingFlags & self.APPLOGF_LEVEL_VERBOSE)
    def isQuietLog(self):
        return (self.loggingFlags == self.APPLOGF_LEVEL_ALWAYS | self.APPLOGF_LEVEL_ERROR)



#########################################################################################
#                                                                                       #
#                                     Other Logic                                       #
#                                                                                       #
#########################################################################################


#
# Writes a message directly to console (stdout) without newline, bypassing log
#
def consoleWriteLine(msg):
    sys.stdout.write(msg)
    sys.stdout.flush()

#
# Clears the current line of the console by printing a carriage return, a
# line of spaces, then another carriage return to return cursor to first
# column of line
#
def consoleClearLine():
    sys.stdout.write("\r" + " "*78 + "\r")
    sys.stdout.flush()

#
# returns a date/time string in mm/dd/yy hh:mm:ss format for specified
# epoch time - if epoch time is None then returns date/time string for
# current time
#
def getDateTimeStr(timeEpoch=None, fMilitaryTime=False):
    if timeEpoch == None:
        timeEpoch = time.time()
    timeStruct = time.localtime(timeEpoch)
    if not fMilitaryTime:
        timeStr = time.strftime("%m/%d/%y %I:%M:%S %p", timeStruct)
    else:
        timeStr = time.strftime("%m/%d/%y %H:%M:%S", timeStruct)
    return timeStr


#
# determines if the specified string is valid (not None) and that it's not-empty and not
# only whitespace
#
def isStrValidWithNonWhitespaceChars(str):
    return str != None and len(str) > 0 and not str.isspace()


#
# returns the number of seconds that have elapsed since
# the specified anchor time. if the anchor time is None
# then this routine returns the current time, which
# the caller can use for a subsequent call to get elapsed
# time. time values are floats
#
def secondsElapsed(timeAnchor):
    timeCurrent = time.time()
    if timeAnchor == None:
        return timeCurrent
    return timeCurrent - timeAnchor


#
# sets app-level globals related to the platform we're running under and
# creates path to app directories, creating them if necessary
#
def establishAppEnvironment():

    g.appStartTimeEpoch = time.time()

    g.isWin32 = (platform.system() == 'Windows')
    g.isOSX = (platform.system() == 'Darwin')

    #
    # determine the directory our script resides in, in case the
    # user is executing from a different working directory.
    #
    g.appDir = os.path.dirname(os.path.realpath(sys.argv[0]))

    if os.getenv(APP_NAME + '_disablelogfile'):
        g.disableLoggingToFile = True

    #
    # determine directory to store app data to, such as log files
    #
    g.appDataDir = None
    appDataDirFromEnv = os.getenv(APP_NAME + '_appdatadir')
    if appDataDirFromEnv:
        # user specified log file directory in environmental variable - use it
        g.appDataDir = appDataDirFromEnv
    else:
        # user didn't specify log file directory - select one based on platform
        if g.isWin32:
            if os.getenv('LOCALAPPDATA'):
                g.appDataDir = os.path.join(os.getenv('LOCALAPPDATA'), APP_NAME_GROUP) # typically C:\Users\<username>\AppData\Local\<appname>
        elif g.isOSX: # for OSX we always try to store our app data under Application Support
            userHomeDir = os.getenv('HOME')
            if userHomeDir:
                applicationSupportDir = os.path.join(userHomeDir, 'Library/Application Support')
                if os.path.exists(applicationSupportDir): # probably not necessary to check existence since every system should have this directory
                    g.appDataDir = os.path.join(applicationSupportDir, APP_NAME_GROUP) # typically /Users/<username>/Library/Application Support/<appname>
    if not g.appDataDir:
        # none of runtime-specific cases above selected an app data directory - use same directory as app file (and hope that it's writeable)
        g.appDataDir = g.appDir
    # create our app data directory if necessary
    if not os.path.exists(g.appDataDir):
        os.makedirs(g.appDataDir)

#
# creates an array of arguments from an argument string, honoring quoted args as a single argument
#
def createArgListFromArgStr(argStr):
    return [x.strip('"') for x in re.split('( |".*?")', argStr) if x.strip()]


#
# generates a unique filename based on an original name by
# adding a -new-%d suffix, repeating until it finds a suffix
# number that's unique for the directory the file is in
#
def generateUniqueFilename(origFilenameWithPath):
    newSuffixCounter = 1
    while True:
        (pathWithFilename, extension) = os.path.splitext(origFilenameWithPath)
        newFilename = "{:s}-new-{:d}{:s}".format(pathWithFilename, newSuffixCounter, extension)
        if not os.path.exists(newFilename):
            return newFilename
        newSuffixCounter += 1


#
# prompts the user for a single-character selection (+enter),
# only allowing characters specfied in validKeyList. check
# is case-insensitive.
#
def promptWithSingleKeyResponse(promptStr, validKeyListStr):
    while True:
        if sys.version_info.major == 2:
            key = raw_input(promptStr)
        else:
            key = input(promptStr)
        key = key.upper()
        if key and validKeyListStr.upper().find(key) != -1:
            return key


#
# splits a path+filename into its three components - path, root, and extension,
# which is returned as a tuple
#
def splitPath(pathWithFilename, fConvertToAbsolutePathBeforeSplit=True):
    if fConvertToAbsolutePathBeforeSplit:
        pathWithFilename = os.path.abspath(pathWithFilename)
    (path, filenameWithExt) = os.path.split(pathWithFilename)
    (root, extension) = os.path.splitext(filenameWithExt)
    return (path, root, extension)



#
# class for output filenames with optional substition fields
#
class OutputNameSpecDict(object):

    # update validateSpecStr() listKeys when updating this list
    KEY_XML_FILENAME_ROOT = 'X'
    KEY_APP_LAUNCH_DATE = 'O'
    KEY_APP_LAUNCH_TIME = 'o'
    KEY_SEQUENCE_NAME = 'S'
    KEY_SEQUENCE_INDEX = 's'
    KEY_TRACK_NAME = 'T'
    KEY_TRACK_INDEX = 't'
    KEY_CLIP_NAME = 'C'
    KEY_COUNT_CLIPS_PROCESSED_TOTAL = 'i'
    KEY_COUNT_CLIPS_PROCESSED_THIS_SEQUENCE = 'j'
    KEY_COUNT_CLIPS_PROCESSED_THIS_TRACK = 'c'
    # update validateSpecStr() listKeys when updating this list

    def __init__(self):
        self.dict = {}

    def setKey(self, key, value):
        self.dict[key] = value

    def getValue(self, key):
        return self.dict[key]

    def keyExists(self, key):
        return key in self.dict

    def convertSpecStr(self, specStr):
        outputStr = ""
        specStrLen = len(specStr)
        specStrIndex = 0
        while specStrIndex < specStrLen:
            char = specStr[specStrIndex]
            if char != '%':
                outputStr += char
            else:
                specStrIndex += 1
                if specStrIndex == specStrLen:
                    raise AssertionError("Output name spec \"{:s}\" ends with a '%' with no substition character following it".format(specStr))
                char = specStr[specStrIndex]
                if char == '%':
                    # literal '%'
                    outputStr += char
                else:
                    if not self.keyExists(char):
                        raise AssertionError("Output name spec \"{:s}\" has invalid substition character '{:s}'".format(specStr), char)
                    outputStr += self.getValue(char)
            specStrIndex += 1
        return outputStr

    @classmethod
    def validateSpecStr(cls, specStr):
        listKeys = [ '%', OutputNameSpecDict.KEY_XML_FILENAME_ROOT, OutputNameSpecDict.KEY_APP_LAUNCH_DATE, OutputNameSpecDict.KEY_APP_LAUNCH_TIME, OutputNameSpecDict.KEY_SEQUENCE_NAME,\
            OutputNameSpecDict.KEY_SEQUENCE_INDEX, OutputNameSpecDict.KEY_TRACK_NAME, OutputNameSpecDict.KEY_TRACK_INDEX, OutputNameSpecDict.KEY_CLIP_NAME, OutputNameSpecDict.KEY_COUNT_CLIPS_PROCESSED_TOTAL,\
            OutputNameSpecDict.KEY_COUNT_CLIPS_PROCESSED_THIS_SEQUENCE, OutputNameSpecDict.KEY_COUNT_CLIPS_PROCESSED_THIS_TRACK ]
        specStrLen = len(specStr)
        specStrIndex = 0
        while specStrIndex < specStrLen:
            if specStr[specStrIndex] == '%':
                specStrIndex += 1
                if specStrIndex == specStrLen:
                    return "Output name spec \"{:s}\" ends with a '%' with no substition character following it".format(specStr)
                if specStr[specStrIndex] not in listKeys:
                    return "Output name spec \"{:s}\" has invalid substition character '{:s}'".format(specStr, specStr[specStrIndex])
            specStrIndex += 1
        return None


#
# called to check if a file exists (for an operation that wants to overwrite a file).
# if the file does exist then an action will be taken based on how the user configured
# our app to handle this scenario ('ifexists' command-line parameter)
#
def checkIfFileExistsAndHandle(pathAndFilename):
    if g.args['ifexists'] != 'overwrite' and os.path.exists(pathAndFilename):
        if g.args['ifexists'] == 'prompt':
            g.applog.info("\"{:s}\" exists".format(pathAndFilename))
            #
            # note that if the user takes too long to respond the MTP session may
            # time out. we'll recover but it'll look messy. need to implement a
            # multi-platform method  to poll for keys so that we can mtpSessionKeepAlive()
            # while we're waiting for a keypress (todo-todo)
            #
            keyResponse = promptWithSingleKeyResponse("(S)kip, (O)verwrite, (U)niquename, (E)xit [+enter]: ", 'soue')
        else:
            keyResponse = ''
        if g.args['ifexists'] == 'skip' or keyResponse == 'S':
            if not keyResponse:
                g.applog.info("Skipping \"{:s}\" - file exists".format(pathAndFilename))
            pathAndFilename = None
        elif g.args['ifexists'] == 'uniquename' or keyResponse == 'U':
            uniqueFilenameWithPath = generateUniqueFilename(pathAndFilename)
            if not keyResponse:
                g.applog.info("\"{:s}\" exists - will write to \"{:s}\"".format(pathAndFilename, uniqueFilenameWithPath))
            pathAndFilename = uniqueFilenameWithPath
        elif g.args['ifexists'] == 'exit' or keyResponse == 'E':
            g.applog.info("\"{:s}\" exists - exiting per user config".format(pathAndFilename))
            cleanupAndExitApp(ERRNO_FILE_EXISTS_USER_SPECIFIED_EXIT)
    return pathAndFilename


#
# spawns the ffmpeg executable with a given command line, waits
# for completion and then returns ffmpeg's exit code
#
class ffmpeg(object):

    #
    # private class variables
    #
    __countInvocations = 0
    __fHaveWarnedAboutLogPathInCurrentDir = False

    @classmethod
    def execute(cls, cmdLineAsStr, msgDuringExec=""):

        argFffmpegPathAndRootFilename = os.path.join(g.ffmpegToolsPath, "ffmpeg")   # Windows systems have .exe extension but this is implied in Win32's proc spawn so no need to append
        argLogLevel = "-loglevel {:s}".format(g.args['ffmpegconsoleloglevel'])
        argExtraArgs = "-y" # -y = overwrite if output file exists

        cmdLineAsStr =  argFffmpegPathAndRootFilename + ' ' + cmdLineAsStr + ' ' + argLogLevel + ' ' + argExtraArgs
        g.applog.debug("ffmpeg-exec: " + cmdLineAsStr)
        cmdLineArgArray = createArgListFromArgStr(cmdLineAsStr)

        #
        # FYI: On Windows systems we have to store the FFREPORT in the current directory because
        # it doesn't support drive letters in the path. Same is true for OSX since it supports
        # colon in the path names. To work around this I don't include any path to the log,
        # so it's stored in the current directory (yuck)
        #
        # I submitted ticket for this here: https://trac.ffmpeg.org/ticket/6399
        #
        if g.args['ffmpegreportloglevel'] != 'none':

            #
            # tell ffmpeg where to store its file log via the FFREPORT environmental variable. The
            # variable doesn't support colons or back-slashes in the path/name of the log file,
            # so for Windows environments we can't use any path that includes a drive letter (or
            # on OSX for any path that includes a colon in it) and we have to convert the Windows
            # back-slashes to forward-slashes
            #
            ffmpegenv = os.environ.copy()
            ffreportFilename = APP_NAME + "_ffmpeg_log.txt"

            if g.appDataDir.find(':') == -1:
                ffreportPath = g.appDataDir
            else:
                # log directory contains a colon - use current directory instead (and hope that it's writable)
                ffreportPath = ""
                if not ffmpeg.__fHaveWarnedAboutLogPathInCurrentDir:
                    g.applog.warning("The app log directory contains a colon but ffmpeg doesn't support colons. Using current directory instead (must be writable)")
                    ffmpeg.__fHaveWarnedAboutLogPathInCurrentDir = True

            ffreportPathAndFilename = os.path.join(ffreportPath, ffreportFilename)
            ffreportPathAndFilename = ffreportPathAndFilename.replace('\\', '/')
            ffmpegenv["FFREPORT"] = "file={:s}:level={:s}".format(ffreportPathAndFilename, g.args['ffmpegreportloglevel'])
        else:
            ffmpegenv = None

        # launch ffmpeg
        fEnableConsoleProgressDisplay = not g.applog.isQuietLog()
        if fEnableConsoleProgressDisplay:
            consoleWriteLine(msgDuringExec)
        try:
            process = subprocess.Popen(cmdLineArgArray, env=ffmpegenv)
        except Exception as e:
            if fEnableConsoleProgressDisplay:
                consoleClearLine()
            g.applog.error("ffmpeg executable launch failed ({:s}). Use --ffmpegdir to specify where to find the ffmpeg executable".format(str(e)))
            return ERRNO_FFMPEG_EXEC_LAUNCH_FAILED
        if not process:
            raise AssertionError('Unable to create process for ffmpeg: "{:s}"'.format(cmdLineAsStr))

        # wait for ffmpeg completion
        try:
            _errno = process.wait()
        except KeyboardInterrupt as e: # <ctrl-c> pressed
            raise
        finally:
            if fEnableConsoleProgressDisplay:
                consoleClearLine()

        if g.args['ffmpegreportloglevel'] != 'none':
            if os.path.exists(ffreportPathAndFilename):
                statInfo = os.stat(ffreportPathAndFilename)
                g.applog.log("--------> start of ffmpeg log [size = {:,} bytes]".format(statInfo.st_size), AppLog.APPLOGF_LEVEL_INFORMATIONAL | AppLog.APPLOGF_DONT_WRITE_TO_CONSOLE)
                g.applog.addFromFile(ffreportPathAndFilename) # add ffmpeg log to our log
                g.applog.log("<-------- end of ffmpeg log [size = {:,} bytes]".format(statInfo.st_size), AppLog.APPLOGF_LEVEL_INFORMATIONAL | AppLog.APPLOGF_DONT_WRITE_TO_CONSOLE)
                deleteFileIgnoreErrors(ffreportPathAndFilename)
            else:
                g.applog.warning("--------> No log found from ffmpeg")

        if _errno:
            g.applog.error("ffmpeg reported error {:d} during operation".format(_errno))


        ffmpeg.__countInvocations += 1
        return _errno


#
# class to represent a source media file described in FCP7's <File> XML element.
# this class also serves as a collector for instances created
#
class VideoSourceFile(object):
    #
    # class variables
    #
    __videoSourceFilesDictByFileID = {}       # dictionary of all files, keyed by file ID
    videoSourceFileList = []                  # array of all files

    #
    # creates new instance of a video source file. 'fileUrl' is the
    # value from the <pathurl> element and 'fileId' is from the 'id'
    # attribute of the <file> element. each instance has the following variables:
    #
    #   'filename'              - Full path+filename to file
    #   'fileId'                - ID value from <file> element attribute
    #   'frameRate'             - Frame rate (integer)
    #   'outputClipFileList'    - List of output clips created from this file (caller maintained)
    #
    def __init__(self, fileUrl, fileId, frameRate):
        urlUnquoted = _urlparse.unquote(fileUrl)[7:]
        localHostPrefixIndex = urlUnquoted.find("localhost/")
        if localHostPrefixIndex != -1:
            if g.isWin32:
                urlUnquoted = urlUnquoted[len("localhost/"):] # remove 'localhost', including trailing forward slash
            else:
                urlUnquoted = urlUnquoted[len("localhost"):] # remove 'localhost'
        self.filename = os.path.abspath(urlUnquoted)
        self.fileId = fileId
        self.frameRate = frameRate
        self.outputClipFileList = []

        if VideoSourceFile.getByFileId(fileId):
            raise AssertionError('VideoSourceFile: "{:s}" already in list'.format(urlUnquoted))

        VideoSourceFile.__videoSourceFilesDictByFileID[fileId] = self   # add this instance to the dictionary
        VideoSourceFile.videoSourceFileList.append(self)                # add this instance to the flat list of instances

        g.applog.debug("XML VideoSourceFile: \"{:s}\", fileId=\"{:s}\", fps={:d}".format(self.filename, self.fileId, self.frameRate))

    #
    # returns an instance corresponding to the specified file ID, or None
    # if there is no instance corresponding to the ID.
    #
    @classmethod
    def getByFileId(cls, fileId):
        if fileId not in VideoSourceFile.__videoSourceFilesDictByFileID:
            return None
        return VideoSourceFile.__videoSourceFilesDictByFileID[fileId]


#
# class to represent an output clip created by this module.
#
class OutputClipFile(object):

    #
    # creates a new instance of an output clip/file object. 'videoSourceFile' is the
    # instance of VideoSourceFile from which this output clip will be created
    # by the caller. 'outputNameSpecDict' is the user-configured filename (or program
    # default if user didn't specify), including supported substition values
    # supported by OutputNameSpecDict. On return, the instance.filename will be set
    # to the full path+filename of the output file, or None if the user chose to
    # skip the file for the case where it conflicts with an existing file at
    # the generated path
    #
    def __init__(self, videoSourceFile, outputNameSpecDict):

        #
        # first split the source filename into its path, filename, and extension
        #
        (path, root, extension) = splitPath(videoSourceFile.filename)
        if extension and extension[0] == '.': # remove leading period in extension
            extension = extension[1:]

        #
        # now build path/filename of output file based on both source path/name and command-line options
        #
        if g.args['combine'] != 'none':
            # we're configured to build combined files, so generate a unique filename for each clip
            outputNameSpec = APP_NAME + "-tmp-%X-%C-%i" # XML source file name + clip name + clip # processed for entire XML
        else:
            # we're configured only build individual clips
            outputNameSpec = g.args['outputnamespec']
            if not outputNameSpec:
                # no user-specified outname name spec. use default
                outputNameSpec = "%C-%i"    # clip name + clip # processed for entire XML

        outputNameRoot = outputNameSpecDict.convertSpecStr(outputNameSpec)

        if g.args['combine'] == 'none':
            # final output is the clip files, so store them in their permanent location (not in scratch)
            if g.outputDirSpecified:
                # user specified an output dir, so use it.
                path = g.outputDir
            # else  we default to storing output clips in same directory as source file ('path' already set to that)
        else:
            # final output is combined file(s)
            if g.scratchDirSpecified:
                # user specified a scratch directory - use it
                path = g.scratchDir
            elif g.outputDirSpecified:
                # user specified an output dir, so use it as the scratch directory
                path = g.outputDir
            # else  we default to storing temporary working clips in same directory as source file ('path' already set to that)

        if g.args['container']:
            # user specified a container (extension). use it in place of the source file's container
            extension = g.args['container']

        outputPathAndFilename = os.path.join(path, outputNameRoot + '.' + extension)

        #
        # handle case of output file conflicting with existing file
        #
        if g.args['combine'] == 'none':
            # the individual clip(s) are the final output, so make sure it doesn't conflict with an existing file
            outputPathAndFilename = checkIfFileExistsAndHandle(outputPathAndFilename) # FYI: Returns None if user decides to skip file
        # else we're building the clip as a temp file (to combine later), so we don't warn about overwriting our own temp files

        self.filename = outputPathAndFilename

        if g.args['combine'] != 'none' and g.args['retaintempclips'] == 'no':
            #
            # we'll be later combining this output clip with others and we're not configured to retain
            # temporary clips after combining, so add this cliop to our delete-on-exit list
            #
            addTempFileToDeleteOnExitList(outputPathAndFilename)



#
# invokes ffmpeg to generate an output video file that is the combination of all clips associated
# with a given group (track, sequence, original source media file). 'outputClipFileList' is an array
# of OutputClipFile objects corresponding to the output clips that will be combined. 'group' describes
# the assocation of the output files (ie, all belonging to the same track, sequence, or sourcemedia file).
# The output clip files are deleted after the group is written, regardless of whether the
# group write was successful.
#
def combineOutputClips(outputClipFileList, group, outputNameSpecDict, groupSourceDirectory):

    (firstFilePath, firstFileRoot, firstFileExtension) = splitPath(outputClipFileList[0].filename)

    outputNameSpec = g.args['outputnamespec']
    if not outputNameSpec:
        # no user-specified outname name spec. use default
        if group == 'track':
            outputNameSpec = "%S-%T"    # Sequence Name-Track Name
        elif group == 'sequence':
            outputNameSpec = "%S"       # Sequence Name
        elif group == 'sourcemedia':
            outputNameSpec = "%C-combined"  # Clipname

    outputNameRoot = outputNameSpecDict.convertSpecStr(outputNameSpec)

    #
    # determine which extension to use
    #
    if g.args['container']:
        # user specified a container (extension). use it in place of the source file's container
        extension = g.args['container']
    else:
        # use container of the first file
        extension = firstFileExtension
        if extension and extension[0] == '.': # remove leading period in extension
            extension = extension[1:]

    #
    # determine directory to store the output file into
    #
    if g.outputDirSpecified:
        # user specified output directory - use it
        outputDir = g.outputDir
    else:
        # user did not specify output directory - use directory of the group's source
        outputDir = groupSourceDirectory

    outputPathAndFilename = os.path.join(outputDir, outputNameRoot + '.' + extension)

    #
    # check if there's a file with the same name of what we're about to generate. if so,
    # do the appropriate action based on how the user configured us to handle conflicts
    #
    outputPathAndFilename = checkIfFileExistsAndHandle(outputPathAndFilename)
    if outputPathAndFilename: # user chose to continue (either renaming, overwriting, etc...)

        #
        # generate text file with list of clips to concatenate (to be passed to ffmpeg). see
        # this link for details: https://trac.ffmpeg.org/wiki/Concatenate
        #
        ffmpegCombineListFilename = os.path.join(g.scratchDir, "{:s}-tmp-{:s}-filelist.txt".format(APP_NAME, outputNameRoot))
        ffmpegCombineListFile = open(ffmpegCombineListFilename, 'w')
        for outputClipFile in outputClipFileList:
            ffmpegCombineListFile.write("file '{:s}'\n".format(outputClipFile.filename))
            if g.args['insertvideo']:
                ffmpegCombineListFile.write("file '{:s}'\n".format(os.path.abspath(g.args['insertvideo'])))
        ffmpegCombineListFile.close()
        addTempFileToDeleteOnExitList(ffmpegCombineListFilename)

        #
        # exec ffmpeg to do combine
        #
        combineCmdLine = "-f concat -safe 0 -i \"{:s}\" -c copy \"{:s}\"".format(ffmpegCombineListFilename, outputPathAndFilename)
        _errno = ffmpeg.execute(combineCmdLine, "Generating: {:s}".format(outputPathAndFilename))
        deleteTempFileAndRemoveFromDeleteOnExitList(ffmpegCombineListFilename)

        #
        # sanity check - verify combined file was created
        #
        if _errno == 0 and not os.path.exists(outputPathAndFilename):
            g.applog.error("ffmpeg reported success creating combined file \"{:s}\" but the file doesn't exist".format(outputPathAndFilename))
            _errno = ERRNO_FFMPEG_OUTPUT_FILE_NOT_FOUND

        if g.applog.isDebugLog():
            stat = os.stat(outputPathAndFilename)
            g.applog.debug("ffmpeg generated file \"{:s}\", size={:,} bytes".format(outputPathAndFilename, stat.st_size))

    else:
        _errno = ERRNO_FILE_SKIPPED_DUE_TO_EXISTING_FILE

    if g.args['retaintempclips'] == 'no':
        for outputClipFile in outputClipFileList:
            deleteTempFileAndRemoveFromDeleteOnExitList(outputClipFile.filename)

    # log the completion
    msg = "Generated \"{:s}\" from {:d} clip(s) (grouped by {:s})".format(outputPathAndFilename, len(outputClipFileList), group)
    if g.applog.isVerboseLog():
        stat = os.stat(outputPathAndFilename)
        msg += " [size={:,} bytes]".format(stat.st_size)
    g.applog.info(msg)

    return _errno


#
# generates combined media files, one for each source media clip, composed
# of all the output clips we generated for each of the source clips
#
def combineSourceMediaClips(outputNameSpecDict):
    countCombinedFilesForSourceMedia = 0
    for videoSourceFile in VideoSourceFile.videoSourceFileList:
        if len(videoSourceFile.outputClipFileList) > 0:
            (sourceFileDirectory, sourceFileNameRoot, _) = splitPath(videoSourceFile.filename)
            outputNameSpecDict.setKey(OutputNameSpecDict.KEY_CLIP_NAME, sourceFileNameRoot)
            _errno = combineOutputClips(videoSourceFile.outputClipFileList, "sourcemedia", outputNameSpecDict, sourceFileDirectory)
            if _errno == 0:
                countCombinedFilesForSourceMedia += 1
            elif _errno != ERRNO_FILE_SKIPPED_DUE_TO_EXISTING_FILE and g.args['haltonffmpegerrors'] == 'yes':
                return (countCombinedFilesForSourceMedia, _errno)
    return (countCombinedFilesForSourceMedia, 0)


#
# converts a time value in seconds into a 'hh:mm:ss' string
#
def secondsToVideoTimeStr(totalSeconds, fractionalSeconds = None, fUseFractionalSecondsEvenIfZero = False):
    hours, remainder = divmod(totalSeconds, 60*60)
    minutes, seconds = divmod(remainder, 60)
    str = "{:02d}:{:02d}:{:02d}".format(hours, minutes, seconds)
    if fractionalSeconds != None and (fractionalSeconds > 0 or fUseFractionalSecondsEvenIfZero):
        str += "{:f}".format(fractionalSeconds)[1:]
    return str


#
# performs an XML find-all for a given XML search string, exiting the app with error if the
# element is not found
#
def xmlFindAllMustSucceed(xmlElement, xmlFindDescStr, elementUserDescription):
    findResultsList = xmlElement.findall(xmlFindDescStr)
    if not findResultsList:
        g.applog.error("XML file has no {:s} elements to process".format(elementUserDescription))
        cleanupAndExitApp(ERRNO_XML_ELEMENT_NOT_FOUND)
    return findResultsList


#
# performs an XML find for a given XML search string, exiting the app with error if the
# element is not found and optionally if the element contains an empty value
#
def xmlFindMustSucceed(xmlElement, xmlFindDescStr, elementUserDescription, fVerifyNonEmptyTextValue=True):
    findResult = xmlElement.find(xmlFindDescStr)
    if findResult == None: # note: can't use "if not findResult" because current Python implementation only returns FALSE if element has no children
        g.applog.error("XML file has no {:s} element to process".format(elementUserDescription))
        cleanupAndExitApp(ERRNO_XML_ELEMENT_NOT_FOUND)
    if fVerifyNonEmptyTextValue and not isStrValidWithNonWhitespaceChars(findResult.text):
        g.applog.error("XML {:s} element is missing value".format(elementUserDescription))
        cleanupAndExitApp(ERRNO_XML_ELEMENT_MISSING_VALUE)
    return findResult


#
# Verifies that a given XML element has all the specified attributes, including optionally also checking
# that the attributes is a non-empty value
#
def xmlElementMustHaveAttributes(xmlElement, attribListArray, elementUserDescription, fVerifyNonEmptyAttributeValue=True):
    for attrib in attribListArray:
        if attrib not in xmlElement.attrib:
            g.applog.error("XML missing \"{:s}\" attribute for {:s} element".format(attrib, elementUserDescription))
            cleanupAndExitApp(ERRNO_XML_ELEMENT_MISSING_ATTRIBUTE)
        if fVerifyNonEmptyAttributeValue and not isStrValidWithNonWhitespaceChars(xmlElement.attrib[attrib]):
            g.applog.error("XML \"{:s}\" attribute is missing value for {:s} element".format(attrib, elementUserDescription))
            cleanupAndExitApp(ERRNO_XML_ELEMENT_MISSING_ATTRIBUTE)


#
# process the seqeunce and clips of a Final Cut Pro 7 XML file, generating
# subclips of each cut and then optionally combining the sublcips into larger
# clips based on their relationship to the original source media, sequence track,
# or sequence (configurable by user)
#
def processFinalCutXML(finalCutXmlFilename):

    (xmlDirectory, xmlFilenameRoot ,_) = splitPath(finalCutXmlFilename)

    #
    # OutputNameSpecDict is used to support user-specified substition characters
    # for the output filenames (--outputnamespec), ie custom filenames based on
    # properties of the media files, source sequence/track info, etc.. This
    # process works by maintaining a dictionary, where the key is the substition
    # character (example: %C, for clip name) and the value for the key is the
    # actual substition value (clip name). So throughout this routine there
    # is logic to build and maintain the dictionary values based on the current
    # element we're processing, so that when we go to generate an output file
    # we'll be able to support the substition values the user specified
    #
    outputNameSpecDict = OutputNameSpecDict()
    outputNameSpecDict.setKey(OutputNameSpecDict.KEY_XML_FILENAME_ROOT, xmlFilenameRoot)
    outputNameSpecDict.setKey(OutputNameSpecDict.KEY_APP_LAUNCH_DATE, time.strftime("%m%d%y", time.localtime(g.appStartTimeEpoch)))  # app launch date (mmddyy)
    outputNameSpecDict.setKey(OutputNameSpecDict.KEY_APP_LAUNCH_TIME, time.strftime("%H%M%S", time.localtime(g.appStartTimeEpoch)))  # app launch time (hhmmss)

    #
    # load the FCP7 Pro XML file into the parser, which will do the initial sanity check of the XML structure
    #
    # For information on the Apple Final Cut Pro 7 XML format, go to:
    #   https://developer.apple.com/library/content/documentation/AppleApplications/Reference/FinalCutPro_XML/
    #
    try:
        tree = ET.parse(finalCutXmlFilename)
    except ET.ParseError as e:
        g.applog.error("XML Parsing error for \"{:s}\": {:s}".format(finalCutXmlFilename, str(e)))
        cleanupAndExitApp(ERRNO_XML_PARSE_FAILED)
    except Exception as e:
        g.applog.error("Error processing \"{:s}\": {:s}".format(finalCutXmlFilename, str(e)))
        cleanupAndExitApp(ERRNO_XML_PARSE_FAILED)
    root = tree.getroot()
    if root == None or not root.text or root.text == "\n":
        g.applog.error("XML file is missing its root node")
        cleanupAndExitApp(ERRNO_XML_ELEMENT_NOT_FOUND)

    #
    # first we find all <file> items which contain path URLs (path+filenames in URL phone)
    # to media files and build a VideoSourceFile instance for each that we find.
    #
    # Each source media file is represented by a <file> item. A <file> item can either
    # be a full instance describing the file, in which case it'll contain items such
    # as <pathurl> containing the path+filename to the file, among other information,
    # or it can be just a reference to the <file> that was established elsewhere in the
    # XML. For each source media file there should only be one <file> which is the
    # full instance, and then one or more reference <file> elements which point back
    # to the file. The reference <file> element allows a given sequence to reference the
    # same file multiple times without having to repeat all the information about the file.
    # The correlation between the <file> references and the full instance is made by way
    # of a fileid attribute on the <file> element, for example: <file id="file-48">
    #
    # The location of the full-instance of the <file> within the XML will vary based on where
    # the file is first used in the project. Sometimes the full-instance will be embedded
    # within a <sequence> parent chain, while other times the full-instance elements will
    # be laid out in a separate area. We can handle all these cases by simply performing
    # an xpath search of all <file> elements which contain a <pathurl> child element
    #
    filesWithPathURLs = xmlFindAllMustSucceed(root, ".//file[pathurl]", "source media file (with a puthurl)")
    for file in filesWithPathURLs:
        xmlElementMustHaveAttributes(file, ['id'], "source media file")
        fileId = file.attrib['id']
        fileUrlElement = xmlFindMustSucceed(file, "pathurl", "Path URL of source media file")
        rateElement = xmlFindMustSucceed(file, "./rate/timebase", "frame-rate (timebase)")
        try:
            frameRate = int(rateElement.text)
        except ValueError as e:
            g.applog.error("Frame-rate (timebase) of clip contain non-numeric values")
            return ERRNO_XML_ELEMENT_HAS_NON_NUMERIC_VALUES
        VideoSourceFile(fileUrlElement.text, fileId, frameRate)
        #
        # note that we don't verify the existence of the source file here - we only verify it
        # if/when it's referenced by a clip item. that way we don't generate errors for file(s)
        # we wont even be looking at
        #


    #
    # process sequences
    #
    sequences = xmlFindAllMustSucceed(root, ".//sequence", "sequence")
    countOutputClipsGenerated_AllSequences = 0
    countTrackCombinedFilesWritten = 0
    countSequenceCombinedFilesWritten = 0
    fHaveWarnedAboutFpsMismatch = False
    for sequenceIndex, sequence in enumerate(sequences):

        outputClipFileList_ThisSequence = []

        sequenceNameElement = sequence.find("name")
        if sequenceNameElement != None and isStrValidWithNonWhitespaceChars(sequenceNameElement.text):
            sequenceName = sequenceNameElement.text
        else:
            sequenceName = "seq{:d}".format(sequenceIndex+1)

        g.applog.verbose("Processing sequence #{:d}, name=\"{:s}\"".format(sequenceIndex+1, sequenceName))

        outputNameSpecDict.setKey(OutputNameSpecDict.KEY_SEQUENCE_NAME, sequenceName)
        outputNameSpecDict.setKey(OutputNameSpecDict.KEY_SEQUENCE_INDEX, str(sequenceIndex+1))

        #
        # make sure this is a sequence we're configured to process
        #
        if g.args['onlysequences'] and sequenceName not in g.args['onlysequences']:
            g.applog.verbose("Skpping sequence \"{:s}\" because it's not in --onlysequences".format(sequenceName))
            continue
        if g.args['excludesequences'] and sequenceName in g.args['excludesequences']:
            g.applog.verbose("Skpping sequence \"{:s}\" because it's in --excludesequences".format(sequenceName))
            continue

        #
        # process tracks on this sequence
        #
        tracks = sequence.findall("./media/video/track") # returns empty array if no tracks found
        for trackIndex, track in enumerate(tracks):

            outputClipFileList_ThisTrack = []

            trackName = track.attrib['MZ.TrackName'] if 'MZ.TrackName' in track.attrib and isStrValidWithNonWhitespaceChars(track.attrib['MZ.TrackName']) else None

            outputNameSpecDict.setKey(OutputNameSpecDict.KEY_TRACK_INDEX, str(trackIndex+1))
            outputNameSpecDict.setKey(OutputNameSpecDict.KEY_TRACK_NAME, trackName if trackName else outputNameSpecDict.getValue(OutputNameSpecDict.KEY_TRACK_INDEX)) # use track # as name if track has no name

            g.applog.verbose("Processing sequence \"{:s}\" - track #{:d}, track name=\"{:s}\"".format(sequenceName, trackIndex+1, trackName if trackName else "<Unnamed>"))

            #
            # make sure this is a track we're configured to process
            #
            if g.args['onlytracknumbers'] and trackIndex not in g.args['onlytracknumbers']:
                g.applog.verbose("Skpping track #{:d} because it's not in --onlytracknumbers".format(trackIndex+1))
                continue
            if g.args['excludetracknumbers'] and trackIndex in g.args['excludetracknumbers']:
                g.applog.verbose("Skpping track #{:d} because it's in --excludetracknumbers".format(trackIndex+1))
                continue
            if trackName:
                if g.args['onlytracks'] and trackName not in g.args['onlytracks']:
                    g.applog.verbose("Skpping track \"{:s}\" because it's not in --onlytracks".format(trackName+1))
                    continue
                if g.args['excludetracks'] and trackName in g.args['excludetracks']:
                    g.applog.verbose("Skpping track \"{:s}\" because it's in --excludetracks".format(trackName+1))
                    continue

            #
            # process clip(items) on this track
            #
            clipItems = track.findall("clipitem") # returns empty array if no clipitems found
            if not clipItems:
                g.applog.debug("No source clip items found in sequence \"{:s}\", track #{:d}".format(sequenceName, trackIndex+1))
                continue

            for clipItemIndex, clipItem in enumerate(clipItems):

                #
                # process this clip/cut
                #

                g.applog.debug("Processing clip #{:d}\"".format(clipItemIndex+1))

                timeBaseElement = xmlFindMustSucceed(clipItem, "./rate/timebase", "clip timebase")
                clipInPointElement = xmlFindMustSucceed(clipItem, "in", "clip in-point")
                clipOutPointElement = xmlFindMustSucceed(clipItem, "out", "clip out-point")
                clipNameElement = xmlFindMustSucceed(clipItem, "./name", "clip name")
                fileElement = xmlFindMustSucceed(clipItem, "./file", "clip file ID", fVerifyNonEmptyTextValue=False) # 'file' element will be empty when it only references a file rather than defining one

                (_, clipNameRoot, _) = splitPath(clipNameElement.text)
                outputNameSpecDict.setKey(OutputNameSpecDict.KEY_CLIP_NAME, clipNameRoot)

                outputNameSpecDict.setKey(OutputNameSpecDict.KEY_COUNT_CLIPS_PROCESSED_TOTAL, str(countOutputClipsGenerated_AllSequences+1))
                outputNameSpecDict.setKey(OutputNameSpecDict.KEY_COUNT_CLIPS_PROCESSED_THIS_SEQUENCE, str(len(outputClipFileList_ThisSequence)+1))
                outputNameSpecDict.setKey(OutputNameSpecDict.KEY_COUNT_CLIPS_PROCESSED_THIS_TRACK, str(len(outputClipFileList_ThisTrack)+1))

                videoSourceFile = VideoSourceFile.getByFileId(fileElement.attrib['id'])
                if not videoSourceFile:
                    g.applog.error("Unable to locate source file XML ID \"{:s}\" in sequence \"{:s}\", track #{:d} ({:s})".format(file.attrib['id'], sequenceName, trackIndex+1, trackName if trackName else "unnamed track"))
                    return ERRNO_VIDEO_SOURCE_FOR_CLIP_REF_NOT_FOUND
                if not os.path.exists(videoSourceFile.filename):
                    g.applog.error("Could not find the source media file \"{:s}\" (ID \"{:s}\") referenced in sequence \"{:s}\", track #{:d} ({:s})".format(videoSourceFile.filename, file.attrib['id'], sequenceName, trackIndex+1, trackName if trackName else "unnamed track"))
                    return ERRNO_SOURCE_MEDIA_FILE_NOT_FOUND

                #
                # process the clip in/out points
                #

                # first convert the in/out point text elements to scalar variables. these points are specified in the XML as frame #'s
                try:
                    fpsClipItem = int(timeBaseElement.text)
                    clipInPointFrame = int(clipInPointElement.text)
                    clipOutPointFrame = int(clipOutPointElement.text)
                except ValueError as e:
                    g.applog.error("Timebase or clip in/out points contain non-numeric values")
                    return ERRNO_XML_ELEMENT_HAS_NON_NUMERIC_VALUES

                if fpsClipItem != videoSourceFile.frameRate and not fHaveWarnedAboutFpsMismatch:
                    g.applog.warning("Clip in sequence \"{:s}\" has a frame-rate of {:d}fps but \"{:s}\" has native frame-rate is {:d}fps. Using native rate. Disabling warning for remainder of session.".format(sequenceName, fpsClipItem, videoSourceFile.filename, videoSourceFile.frameRate))
                    fHaveWarnedAboutFpsMismatch = True

                # extend the in/out points with "handles" (extra footage from source clip) if the user configured us to do so
                if g.args['handles']:
                    # user configured us to add handles (extend clips)
                    handlesInFrames = g.args['handles'] * videoSourceFile.frameRate
                    clipInPointFrame -= handlesInFrames
                    clipInPointFrame = max(clipInPointFrame, 0) # make sure we don't extend start handle to a negative frame value
                    clipOutPointFrame += handlesInFrames        # Note: ffmpeg handles "-to" values that extend beyond end of clip, so no need to worry about constraining the handles we add to the end


                # conver the frame #'s of the in/out points to seconds and sub-seconds
                (clipInPointSeconds, clipInPointRemainder) = divmod(clipInPointFrame, videoSourceFile.frameRate)
                clipInPointFractionalSeconds = clipInPointRemainder / videoSourceFile.frameRate
                (clipOutPointSeconds, clipOutPointRemainder) = divmod(clipOutPointFrame, videoSourceFile.frameRate)
                clipOutPointFractionalSeconds = clipOutPointRemainder / videoSourceFile.frameRate

                # now convert the in/out points to strings in the form of hh:mm:ss.sub_seconds
                clipInPointTimeStr = secondsToVideoTimeStr(clipInPointSeconds, clipInPointFractionalSeconds)
                clipOutPointTimeStr = secondsToVideoTimeStr(clipOutPointSeconds, clipOutPointFractionalSeconds)

                g.applog.debug("clipItem: fileId=\"{:s}\", time=[{:s} - {:s}], name=\"{:s}\"".format(videoSourceFile.fileId, clipInPointTimeStr, clipOutPointTimeStr, clipNameElement.text))

                #
                # generate the command line we will use to generate the clip from this source media file
                #
                outputClipFile = OutputClipFile(videoSourceFile, outputNameSpecDict)
                if not outputClipFile.filename:
                    # file generation is being skipped by user due to conflict with existing file with same name
                    continue
                argInputFile = "-i \"{:s}\"".format(videoSourceFile.filename)
                argSeekIn = "-ss {:s}".format(clipInPointTimeStr)   # go to https://trac.ffmpeg.org/wiki/Seeking for information about -ss and -to
                argSeekOut = "-to {:s}".format(clipOutPointTimeStr)
                argVideoCodecArgs = g.args['videoargs']
                argAudioCodecArgs = g.args['audioargs']
                argUserArgs = g.args['ffmpegargs']
                argOutputFile = "\"{:s}\"".format(outputClipFile.filename)

                # note: some of the arguments may have emtpy strings which means we'll be inserting extra spaces on the command line - those will be ignored by ffmpeg
                ffmegCmdLineStr = argSeekIn + ' ' + argInputFile + ' ' + argSeekOut + ' ' + argVideoCodecArgs + ' ' + argAudioCodecArgs + ' ' + argUserArgs + ' ' + argOutputFile

                #
                # execute ffmpeg
                #
                _errno = ffmpeg.execute(ffmegCmdLineStr, "Generating: {:s}".format(outputClipFile.filename))
                if _errno:
                    if g.args['haltonffmpegerrors'] == 'yes':
                        return _errno
                    # configured to ignore errors
                    continue

                #
                # sanity check - verify the output clip was created
                #
                if not os.path.exists(outputClipFile.filename):
                    g.applog.error("ffmpeg reported success of converting \"{:s}\" to \"{:s}\" but the output file doesn't exist".format(videoSourceFile.filename, outputClipFile.filename))
                    return ERRNO_FFMPEG_OUTPUT_FILE_NOT_FOUND

                if g.args['combine'] == 'none' or g.applog.isVerboseLog():
                    msg = "Generated clip file \"{:s}\"".format(outputClipFile.filename)
                    if g.applog.isVerboseLog():
                        stat = os.stat(outputClipFile.filename)
                        msg += " [size={:,} bytes]".format(stat.st_size)
                    g.applog.info(msg)


                #
                # clip successfully created
                #
                outputClipFileList_ThisSequence.append(outputClipFile)
                outputClipFileList_ThisTrack.append(outputClipFile)
                videoSourceFile.outputClipFileList.append(outputClipFile)
                countOutputClipsGenerated_AllSequences += 1

            #
            # finished clips on this track
            #
            g.applog.verbose("Processed {:d} clip(s) for sequence \"{:s}\" - track #{:d}, track name=\"{:s}\"".format(len(outputClipFileList_ThisTrack), sequenceName, trackIndex+1, trackName if trackName else "<Unnamed>"))

            #
            # generate a combined video file for all clips on this track if we're configured to combine by track
            #
            if g.args['combine'] == 'track' and len(outputClipFileList_ThisTrack) > 0:
                _errno = combineOutputClips(outputClipFileList_ThisTrack, 'track', outputNameSpecDict, xmlDirectory)
                if _errno and _errno != ERRNO_FILE_SKIPPED_DUE_TO_EXISTING_FILE and g.args['haltonffmpegerrors'] == 'yes':
                    return _errno
                if not _errno:
                    countTrackCombinedFilesWritten += 1

        #
        # finished clips on this sequence
        #
        if len(outputClipFileList_ThisSequence) == 0:
            g.applog.warning("No source clip items found for sequence \"{:s}\"".format(sequenceName))

        #
        # generate a combined video file for all clips on this sequence if we're configured to combine by sequence
        #
        if g.args['combine'] == 'sequence' and len(outputClipFileList_ThisSequence) > 0:
            _errno = combineOutputClips(outputClipFileList_ThisSequence, 'sequence', outputNameSpecDict, xmlDirectory)
            if _errno and _errno != ERRNO_FILE_SKIPPED_DUE_TO_EXISTING_FILE and g.args['haltonffmpegerrors'] == 'yes':
                return _errno
            if not _errno:
                countSequenceCombinedFilesWritten += 1

    #
    # finished all sequences
    #

    #
    # generate a combined video file for all clips associated with each source file if we're configured to combine by source file
    #
    if g.args['combine'] == 'sourcemedia':
        (countCombinedFilesForSourceMedia, _errno) = combineSourceMediaClips(outputNameSpecDict)
        if _errno and g.args['haltonffmpegerrors'] == 'yes':
            return _errno

    #
    # print summary report
    #
    if not countOutputClipsGenerated_AllSequences:
        g.applog.minimal("Done: No clips found to process in \"{:s}\"".format(finalCutXmlFilename))
    else:
        if g.args['combine'] == 'none':
            g.applog.minimal("Done: Generated {:d} individual clip(s)".format(countOutputClipsGenerated_AllSequences))
        elif g.args['combine'] == 'sourcemedia':
            g.applog.minimal("Done: Generated {:d} combined media file(s) with clips grouped by source media".format(countCombinedFilesForSourceMedia))
        elif g.args['combine'] == 'track':
            g.applog.minimal("Done: Generated {:d} combined media file(s) with clips grouped by track".format(countTrackCombinedFilesWritten))
        elif g.args['combine'] == 'sequence':
            g.applog.minimal("Done: Generated {:d} combined media file(s) with clips grouped by sequence".format(countSequenceCombinedFilesWritten))

    return 0


#
# deletes a file, ignoring any potential errors (ie, success/failure doesn't matter)
#
def deleteFileIgnoreErrors(filename):
    try:
        os.remove(filename)
    except:
        pass


#
# adds a file to the delete-on-exit list. This list is
# used to delete any temporary files created during the course
# of the app in the event the app terminates early due
# to an error or exception
#
def addTempFileToDeleteOnExitList(filename):
    g.filesToDeleteOnAppExit.append(filename)


#
# deletes a file, removing from the delete-on-exit list
#
def deleteTempFileAndRemoveFromDeleteOnExitList(filename):
    if filename not in g.filesToDeleteOnAppExit:
        g.applog.warning("Temporary file \"{:s}\" being deleted is not on internal tracking list".format(filename))
    else:
        g.filesToDeleteOnAppExit.remove(filename)
    deleteFileIgnoreErrors(filename)


#
# deletes all files marked for deletion upon exit. this mechanism is necessary to
# delete a file we were downloading/writing but failed before the operation could
# completed. we don't want to leave a partially written file, otherwise the user
# might think it's a valid file
#
def deleteTempFilesInDeleteOnExitList():
    for filenameWithPath in g.filesToDeleteOnAppExit:
        g.applog.debug("deleteTempFilesInDeleteOnExitList(): Processing {:s}".format(filenameWithPath))
        try: # ignore os.path.exists() errors
            if (os.path.exists(filenameWithPath)):
                g.applog.verbose("Deleting temp file \"{:s}\" because operation failed".format(filenameWithPath))
                deleteFileIgnoreErrors(filenameWithPath)
        except:
            pass


#
# does all cleanup needed before exiting the app
#
def cleanupForAppExit():

    deleteTempFilesInDeleteOnExitList()

    g.applog.log(">>>> {:s} session over - App Exit Time: {:s}".format(APP_NAME, getDateTimeStr(fMilitaryTime=True)), AppLog.APPLOGF_LEVEL_ALWAYS | AppLog.APPLOGF_DONT_WRITE_TO_CONSOLE)
    g.applog.shutdown()


#
# performs cleanup and then exits app
#
def cleanupAndExitApp(_errno):
    cleanupForAppExit()
    if _errno != 0 and g.applogFilename:
        print("Operation ended in error. Log available at \"{:s}\"".format(g.applogFilename))
    sys.exit(_errno)


#
# initializes the class responsible for logging app messages, then generates
# the first few messages with the app's banner and version information
#
def initAppLog():

    g.applog = AppLog()

    if not g.disableLoggingToFile:
        applogFilename = os.path.join(g.appDataDir, APP_NAME + "-log-last.txt")
        applogLifetimeFilename = os.path.join(g.appDataDir, APP_NAME + "-log-lifetime.txt")
    else:
        applogFilename = None
        applogLifetimeFilename = None
    g.applogFilename = applogFilename

    _errno = g.applog.startLogging(loggingFlags=AppLog.APPLOGF_LEVEL_MINIMAL | AppLog.APPLOGF_LEVEL_INFORMATIONAL | AppLog.APPLOGF_LEVEL_ERROR, sessionLogFilename=applogFilename, lifetimeLogFilename=applogLifetimeFilename)
    if _errno:
        sys.exit(_errno)


#
# main method
#
def main():

    #
    # establish our app environment, including our app-specific subdirectories
    #
    establishAppEnvironment()

    #
    # init applog, to allow logging of output to log files
    #
    initAppLog()

    #
    # process command line arguments
    #
    processCmdLine()

    #
    # process the sequences/clips
    #
    try:
        _errno = processFinalCutXML(g.args['xmlsourcefile'][0])
    except KeyboardInterrupt as e:
        g.applog.error(">> Terminated by user keypress - cleaning up, please wait... <<")
        _errno = errno.EINTR
    except Exception as e:
        cleanupForAppExit()
        raise # popagate exception

    return _errno


#
# program entry point
#
#
# program entry point
#
if __name__ == "__main__":
    _errno = main()
    cleanupAndExitApp(_errno)
